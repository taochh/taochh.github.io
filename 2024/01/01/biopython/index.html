<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>biopython中文说明书（翻译自2023年英文说明书） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1. biopython介绍官网	中文使用手册（2013）	[英文使用手册（2023）](D:\TAO\电子书\python\biopython说明书（英文 2023更新）.pdf)	github仓库  Biopython是一个用于计算分子生物学的免费Python模块的集合 biopython 的想法来自于Jeff Chang 和 Andrew Dalke，1999年，随后大量开发者加入。2000">
<meta property="og:type" content="article">
<meta property="og:title" content="biopython中文说明书（翻译自2023年英文说明书）">
<meta property="og:url" content="http://example.com/2024/01/01/biopython/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. biopython介绍官网	中文使用手册（2013）	[英文使用手册（2023）](D:\TAO\电子书\python\biopython说明书（英文 2023更新）.pdf)	github仓库  Biopython是一个用于计算分子生物学的免费Python模块的集合 biopython 的想法来自于Jeff Chang 和 Andrew Dalke，1999年，随后大量开发者加入。2000">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/01/01/biopython/assets/image-20231227224117041.png">
<meta property="og:image" content="http://example.com/2024/01/01/biopython/assets/image-20231228190504240.png">
<meta property="og:image" content="http://example.com/assets/image-20231230110033725.png">
<meta property="article:published_time" content="2023-12-31T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-22T14:52:58.585Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="biopython">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/01/01/biopython/assets/image-20231227224117041.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-biopython" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/01/biopython/" class="article-date">
  <time class="dt-published" datetime="2023-12-31T16:00:00.000Z" itemprop="datePublished">2024-01-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/">生物信息</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      biopython中文说明书（翻译自2023年英文说明书）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-biopython介绍"><a href="#1-biopython介绍" class="headerlink" title="1. biopython介绍"></a>1. biopython介绍</h2><p><a target="_blank" rel="noopener" href="https://biopython.org/">官网</a>	<a target="_blank" rel="noopener" href="https://doc.yonyoucloud.com/doc/Biopython-cn/index.html#">中文使用手册（2013）</a>	[英文使用手册（2023）](D:\TAO\电子书\python\biopython说明书（英文 2023更新）.pdf)	<a target="_blank" rel="noopener" href="https://github.com/biopython/biopython">github仓库</a></p>
<ul>
<li>Biopython是一个用于计算分子生物学的免费Python模块的集合</li>
<li>biopython 的想法来自于Jeff Chang 和 Andrew Dalke，1999年，随后大量开发者加入。2000年发布了第一个发行版。</li>
<li>biopython属于开源生物信息基金（Open Bioinformatics Foundation,OBF）</li>
</ul>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><h3 id="2-1-linux-MacOS"><a href="#2-1-linux-MacOS" class="headerlink" title="2.1 linux&#x2F;MacOS"></a>2.1 linux&#x2F;MacOS</h3><p>通过 virtualenv 或者 Anaconda 安装</p>
<h4 id="2-1-1-使用-Conda-安装"><a href="#2-1-1-使用-Conda-安装" class="headerlink" title="2.1.1 使用 Conda 安装"></a>2.1.1 使用 Conda 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装虚拟环境</span></span><br><span class="line">conda create -n biopy python -y</span><br><span class="line">conda activate biopy</span><br><span class="line"><span class="comment">#安装 biopython</span></span><br><span class="line">conda install -y biopython</span><br><span class="line"><span class="comment">#测试是否安装成功</span></span><br><span class="line">python</span><br><span class="line">import Bio</span><br><span class="line">Bio.__version__</span><br></pre></td></tr></table></figure>

<img src="./assets/image-20231227224117041.png" alt="image-20231227224117041" style="zoom:50%;" />

<h3 id="2-2-Windows"><a href="#2-2-Windows" class="headerlink" title="2.2 Windows"></a>2.2 Windows</h3><p>打开终端进行安装</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 更新 pip</span><br><span class="line">python -m pip install --upgrade pip</span><br><span class="line"># 安装 biopython</span><br><span class="line">python -m pip install --user biopython</span><br><span class="line">#测试是否安装成功</span><br><span class="line">python</span><br><span class="line">import Bio</span><br><span class="line">Bio.__version__</span><br></pre></td></tr></table></figure>

<h2 id="3-序列对象"><a href="#3-序列对象" class="headerlink" title="3. 序列对象"></a>3. 序列对象</h2><ul>
<li>Bio.Seq 模块中的 Seq 类<ul>
<li>complement()、reverse_complement()</li>
<li>transcribe()、back_transcribe()、translate()</li>
</ul>
</li>
<li>Bio.Seq 模块中的 MutableSeq 类<ul>
<li>remove()、reverse()、append()</li>
</ul>
</li>
<li>Bio.Data 模块中的 CodonTable 模块<ul>
<li>变量：unambiguous_dna_by_id、unambiguous_dna_by_name</li>
<li>实例属性：start_codons、stop_codons、forward_table、back_table</li>
</ul>
</li>
<li>字符串方法<ul>
<li>len()、str()</li>
<li>enumerate()</li>
<li>count()</li>
<li>upper()、lower()</li>
<li>join()</li>
<li>index()、find()、rindex()、rfind()</li>
</ul>
</li>
</ul>
<h3 id="3-1-像字符串一样处理-Sequence"><a href="#3-1-像字符串一样处理-Sequence" class="headerlink" title="3.1 像字符串一样处理 Sequence"></a>3.1 像字符串一样处理 Sequence</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.1 Sequences act like strings</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">my_seq = Seq(<span class="string">&#x27;CCCGGGTT&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index,seq <span class="keyword">in</span> <span class="built_in">enumerate</span>(my_seq): <span class="comment">#枚举</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;index&#125;</span> <span class="subst">&#123;seq&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_seq[<span class="number">0</span>]) <span class="comment">#切片</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_seq)) <span class="comment">#序列长度</span></span><br><span class="line"><span class="built_in">print</span>(my_seq.count(<span class="string">&quot;CC&quot;</span>)) <span class="comment">#不重叠计数</span></span><br><span class="line"><span class="built_in">print</span>(my_seq.count_overlap(<span class="string">&quot;CC&quot;</span>)) <span class="comment">#重叠计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#计算GC含量</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqUtils</span><br><span class="line"></span><br><span class="line">my_seq = Seq(<span class="string">&#x27;AATTCCGGS&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(SeqUtils.gc_fraction(my_seq))</span><br></pre></td></tr></table></figure>
<h3 id="3-2-序列切片"><a href="#3-2-序列切片" class="headerlink" title="3.2 序列切片"></a>3.2 序列切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.2 Slicing a sequences</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">my_seq = Seq(<span class="string">&#x27;CCCGGGTT&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_seq[::-<span class="number">1</span>]) <span class="comment">#序列反向</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-序列转换为字符串"><a href="#3-3-序列转换为字符串" class="headerlink" title="3.3 序列转换为字符串"></a>3.3 序列转换为字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.3 Turning Seq objects into strings</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">my_seq = Seq(<span class="string">&#x27;CCCGGGTT&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_seq)</span><br><span class="line">my_seq_tostring = <span class="built_in">str</span>(my_seq) <span class="comment">#转换为字符串</span></span><br><span class="line"><span class="built_in">print</span>(my_seq)</span><br><span class="line"></span><br><span class="line">fasta_format_string = <span class="string">f&#x27;&gt;example\n<span class="subst">&#123;my_seq&#125;</span>\n&#x27;</span> <span class="comment">#输出为 fasta 格式</span></span><br><span class="line"><span class="built_in">print</span>(fasta_format_string)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-连接多条序列"><a href="#3-4-连接多条序列" class="headerlink" title="3.4 连接多条序列"></a>3.4 连接多条序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.4 合并多条序列</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">my_seq1 = Seq(<span class="string">&#x27;AAAAAA&#x27;</span>)</span><br><span class="line">my_seq2 = Seq(<span class="string">&#x27;TTTTTT&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(my_seq1 + my_seq2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的 join 方法插入序列</span></span><br><span class="line">contig = [Seq(<span class="string">&#x27;AAA&#x27;</span>),Seq(<span class="string">&#x27;TTTT&#x27;</span>),Seq(<span class="string">&#x27;CCCCC&#x27;</span>)]</span><br><span class="line">spacer = Seq(<span class="string">&#x27;N&#x27;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(spacer.join(contig))</span><br></pre></td></tr></table></figure>

<h3 id="3-5-改变大小写"><a href="#3-5-改变大小写" class="headerlink" title="3.5 改变大小写"></a>3.5 改变大小写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.5 改变大小写</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">dna_seq = Seq(<span class="string">&#x27;aaatTTCG&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dna_seq_upper = dna_seq.upper()</span><br><span class="line">dna_seq_lower = dna_seq.lower()</span><br><span class="line"><span class="built_in">print</span>(dna_seq_upper,dna_seq_lower)</span><br><span class="line"></span><br><span class="line"><span class="comment">#改变大小写有时候比较有用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TTTC&#x27;</span> <span class="keyword">in</span> dna_seq)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;TTTC&#x27;</span> <span class="keyword">in</span> dna_seq_upper)</span><br></pre></td></tr></table></figure>

<h3 id="3-6-核酸序列与反向互补"><a href="#3-6-核酸序列与反向互补" class="headerlink" title="3.6 核酸序列与反向互补"></a>3.6 核酸序列与反向互补</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.6 核酸序列与反向互补</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">dna_seq = Seq(<span class="string">&#x27;AAATTTCG&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;互补：<span class="subst">&#123;dna_seq.complement()&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;反向互补：<span class="subst">&#123;dna_seq.reverse_complement()&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;反向：<span class="subst">&#123;dna_seq[::-<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-7-转录"><a href="#3-7-转录" class="headerlink" title="3.7 转录"></a>3.7 转录</h3><p>转录需要注意编码链与模板链，在生物学上，mRNA通常为模板链的反向互补链将T替换成U（即编码链）。在 biopython 中，transcribe()方法仅仅将输入的序列的T碱基替换为U，因此需要注意，若输入的是模板链，中间需要增加一步反向互补的步骤。</p>
<img src="./assets/image-20231228190504240.png" alt="image-20231228190504240" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.7 转录</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">conding_strand = Seq(<span class="string">&#x27;AAATTTCGGG&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;coding strand:<span class="subst">&#123;conding_strand&#125;</span>&#x27;</span>)</span><br><span class="line">templete_strand = conding_strand.reverse_complement()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;templete strand:<span class="subst">&#123;templete_strand&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mRNA = conding_strand.transcribe()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;mRNA:<span class="subst">&#123;mRNA&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cDNA = mRNA.back_transcribe()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;cDNA:<span class="subst">&#123;cDNA&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-8-翻译"><a href="#3-8-翻译" class="headerlink" title="3.8 翻译"></a>3.8 翻译</h3><p>遗传密码编码表参考自<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi">NCBI</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.8 翻译</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">coding_strand = Seq(<span class="string">&#x27;ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG&#x27;</span>)</span><br><span class="line">mRNA = Seq(<span class="string">&#x27;AUGGCCAUUGUAAUGGGCCGCUGAAAGGGUGCCCGAUAG&#x27;</span>) </span><br><span class="line"></span><br><span class="line">protein1 = mRNA.translate() <span class="comment">#从mRNA开始翻译</span></span><br><span class="line">protein2 = coding_strand.translate() <span class="comment">#从编码链开始翻译</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_from_mRNA:<span class="subst">&#123;protein1&#125;</span>\nprotein_from_DNA:<span class="subst">&#123;protein2&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用不同的密码子表</span></span><br><span class="line">protein3 = mRNA.translate(table=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_from_mito:<span class="subst">&#123;protein3&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在遇见第一个终止密码子时停止翻译</span></span><br><span class="line">protein4 = mRNA.translate(to_stop=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_to_stop:<span class="subst">&#123;protein4&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示终止密码子符号</span></span><br><span class="line">protein5 = mRNA.translate(table=<span class="number">2</span>,stop_symbol=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_from_mito:<span class="subst">&#123;protein5&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#细菌cds全长</span></span><br><span class="line">seq = Seq(<span class="string">&#x27;GTGAAAAAGATGCAATCTATCGTACTCGCACTTTCCCTGGTTCTGGTCGCTCCCATGGCAGCACAGGCTGCGGAAATTACGTTAGTCCCGTCAGTAAAATTACAGATAGGCGATCGTGATAATCGTGGCTATTACTGGGATGGAGGTCACTGGCGCGACCACGGCTGGTGGAAACAACATTATGAATGGCGAGGCAATCGCTGGCACCTACACGGACCGCCGCCACCGCCGCGCCACCATAAGAAAGCTCCTCATGATCATCACGGCGGTCATGGTCCAGGCAAACATCACCGCTAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line">protein6 = seq.translate(table=<span class="string">&#x27;Bacterial&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_from_bacterial:<span class="subst">&#123;protein6&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">protein7 = seq.translate(table=<span class="string">&#x27;Bacterial&#x27;</span>,cds=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;protein_from_bacterial_cds_True:<span class="subst">&#123;protein7&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-9-密码子表"><a href="#3-9-密码子表" class="headerlink" title="3.9 密码子表"></a>3.9 密码子表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.9 翻译密码表</span></span><br><span class="line"><span class="keyword">from</span> Bio.Data <span class="keyword">import</span> CodonTable</span><br><span class="line"></span><br><span class="line">standard_table = CodonTable.unambiguous_dna_by_name[<span class="string">&quot;Standard&quot;</span>]</span><br><span class="line">mito_table = CodonTable.unambiguous_dna_by_name[<span class="string">&quot;Vertebrate Mitochondrial&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(standard_table)</span><br><span class="line"></span><br><span class="line"><span class="comment">#与上述语句等价</span></span><br><span class="line">standard_table = CodonTable.unambiguous_dna_by_id[<span class="number">1</span>]</span><br><span class="line">mito_table = CodonTable.unambiguous_dna_by_id[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(standard_table)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;起始密码子:<span class="subst">&#123;standard_table.start_codons&#125;</span>&#x27;</span>)  <span class="comment">#start_condons属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;终止密码子:<span class="subst">&#123;standard_table.stop_codons&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;对应氨基酸:<span class="subst">&#123;standard_table.forward_table[<span class="string">&quot;GCC&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;对应密码子:<span class="subst">&#123;standard_table.back_table[<span class="string">&quot;A&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-10-比较-Seq-对象"><a href="#3-10-比较-Seq-对象" class="headerlink" title="3.10 比较 Seq 对象"></a>3.10 比较 Seq 对象</h3><p>例如，DNA序列<code>ACG</code>，RNA序列<code>ACG</code>，氨基酸序列<code>ACG</code>应该被视为一样吗？Biopython 中把这些 Seq 对象都当作字符串处理，赋值后进行比较可以发现是相等的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  3.10 比较 Seq 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">dna = Seq(<span class="string">&#x27;ACG&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ACG&#x27;</span> == dna)</span><br><span class="line"><span class="built_in">print</span>(dna == <span class="string">&#x27;ACG&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-11-序列包含未知内容"><a href="#3-11-序列包含未知内容" class="headerlink" title="3.11 序列包含未知内容"></a>3.11 序列包含未知内容</h3><p>在某些情况下，一个序列的长度可能是已知的，但不知道构成它的实际字母。例如，GenBank和EMBL文件可能只通过其配置信息来表示一个基因组DNA序列，而不明确指定序列内容。这样的序列可以通过创建一个参数为None的Seq对象来表示，序列的后面是序列长度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  3.11 序列包含未知内容</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">unknown_seq = Seq(<span class="literal">None</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(unknown_seq))</span><br><span class="line"><span class="built_in">print</span>(unknown_seq)</span><br></pre></td></tr></table></figure>

<h3 id="3-12-具有部分定义的序列内容的序列"><a href="#3-12-具有部分定义的序列内容的序列" class="headerlink" title="3.12 具有部分定义的序列内容的序列"></a>3.12 具有部分定义的序列内容的序列</h3><p>以下面的序列为例：人、猩猩染色体7上某一段的多序列比对结果，每一行从左到右为染色体上的起始坐标、序列长度、链、染色体全长、序列信息</p>
<p><img src="/./assets/image-20231230110033725.png" alt="image-20231230110033725"></p>
<p>可以这样定义这个部分序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  3.11 序列包含未知内容</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">seq = Seq(&#123;<span class="number">117512683</span>:<span class="string">&quot;TTGAAAACCTGAATGTGAGAGTCAGTCAAGGATAGT&quot;</span>&#125;,length=<span class="number">159345973</span>)</span><br><span class="line"><span class="built_in">print</span>(seq[<span class="number">117512690</span>:<span class="number">117512700</span>])</span><br><span class="line">seq[<span class="number">117512700</span>:] <span class="comment">#直接在终端中输出与print函数打印出来效果不同</span></span><br><span class="line">seq[<span class="number">1000</span>:<span class="number">1020</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 appending 创建部分定义序列，被添加的是未定义或者部分定义序列均可</span></span><br><span class="line">seq1 = Seq(<span class="string">&#x27;ACGT&#x27;</span>)</span><br><span class="line">undefined_seq = Seq(<span class="literal">None</span>,<span class="number">10</span>)</span><br><span class="line">seq1 + undefined_seq +seq1 <span class="comment">#输出 Seq(&#123;0: &#x27;ACGT&#x27;, 14: &#x27;ACGT&#x27;&#125;, length=18)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-13-MutableSeq-对象"><a href="#3-13-MutableSeq-对象" class="headerlink" title="3.13 MutableSeq 对象"></a>3.13 MutableSeq 对象</h3><p>Seq对象无法直接编辑，Mutable对象可以编辑但需要注意无法作为字典的键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 3.13 MutableSeq 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">seq = Seq(<span class="string">&#x27;ACGTGGTT&#x27;</span>)</span><br><span class="line"><span class="comment"># seq[5] = &#x27;A&#x27; # Seq对象无法直接编辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> MutableSeq</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换为 MutableSeq对象后可直接进行各种编辑操作</span></span><br><span class="line">mutable_seq = MutableSeq(seq)</span><br><span class="line"><span class="built_in">print</span>(mutable_seq)</span><br><span class="line">mutable_seq[<span class="number">5</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(mutable_seq)</span><br><span class="line">mutable_seq.remove(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mutable_seq)</span><br><span class="line">mutable_seq.append(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(mutable_seq)</span><br><span class="line">mutable_seq.reverse()</span><br><span class="line"><span class="built_in">print</span>(mutable_seq)</span><br><span class="line"></span><br><span class="line"><span class="comment">#最后可以转换回Seq对象</span></span><br><span class="line">new_seq = Seq(mutable_seq)</span><br><span class="line"><span class="built_in">print</span>(new_seq)</span><br></pre></td></tr></table></figure>

<h3 id="3-14-查找子序列位置"><a href="#3-14-查找子序列位置" class="headerlink" title="3.14 查找子序列位置"></a>3.14 查找子序列位置</h3><p>index() 方法与 find()方法的区别：找不到序列时，index() 方法返回报错，find() 方法返回 -1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  3.14 查找子序列位置</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq,MutableSeq</span><br><span class="line"></span><br><span class="line">seq = Seq(<span class="string">&quot;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(seq.index(<span class="string">&#x27;ATTGTAA&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(seq.index(<span class="string">b&#x27;ATTGTAA&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(seq.index(<span class="built_in">bytearray</span>(<span class="string">b&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(seq.index(Seq(<span class="string">&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(seq.index(MutableSeq(<span class="string">&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="comment"># print(seq.index(&#x27;ATTAGTG&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(seq.find(<span class="string">&#x27;ATTGTAA&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(seq.find(<span class="string">b&#x27;ATTGTAA&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(seq.find(<span class="built_in">bytearray</span>(<span class="string">b&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(seq.find(Seq(<span class="string">&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(seq.find(MutableSeq(<span class="string">&#x27;ATTGTAA&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(seq.find(<span class="string">&#x27;ATTAGTG&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(seq.rindex(<span class="string">&#x27;GC&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(seq.rfind(<span class="string">&#x27;GC&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#search方法查找多个序列</span></span><br><span class="line"><span class="keyword">for</span> index,subseq <span class="keyword">in</span> seq.search([<span class="string">&#x27;GCC&#x27;</span>,<span class="string">&#x27;ATT&#x27;</span>,<span class="string">&#x27;CCG&#x27;</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;index&#125;</span> <span class="subst">&#123;subseq&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-15-直接处理字符串"><a href="#3-15-直接处理字符串" class="headerlink" title="3.15 直接处理字符串"></a>3.15 直接处理字符串</h3><p>可以直接导入方法，但是还是建议使用 Sequence 对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  3.15 直接处理字符串</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> transcribe,reverse_complement,translate</span><br><span class="line"></span><br><span class="line">seq = <span class="string">&quot;GCCATTGTAATGGGCCGCTGAAAGGGTGCCCGA&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(reverse_complement(seq))</span><br><span class="line"><span class="built_in">print</span>(transcribe(seq))</span><br><span class="line"><span class="built_in">print</span>(translate(seq))</span><br></pre></td></tr></table></figure>

<h2 id="4-序列注释对象"><a href="#4-序列注释对象" class="headerlink" title="4. 序列注释对象"></a>4. 序列注释对象</h2><p>Bio.SeqRecord 模块中的 SeqRecord 类</p>
<ul>
<li>format 方法</li>
<li>reverse_complement 方法</li>
</ul>
<p>Bio.SeqFeature 模块中的 SeqFeature 类</p>
<ul>
<li>Location,position</li>
</ul>
<p>Bio.SeqFeature 模块中的 Reference 类用于引用</p>
<h3 id="4-1-SeqRecord-对象"><a href="#4-1-SeqRecord-对象" class="headerlink" title="4.1 SeqRecord 对象"></a>4.1 SeqRecord 对象</h3><p>SeqRecord（Sequence Record）类在 Bio.SeqRecord 模块中定义。Seq记录模块。这个类允许更高层次的特性，如与序列相关的标识符和特性，并且是 Bio.SeqIO 输入输出接口的基本数据类型。</p>
<p>SeqRecord 具有以下属性：</p>
<ul>
<li>.seq：序列本身。般为 Seq 对象</li>
<li>.id：字符串。用于区分不同序列，如 Accession 号</li>
<li>.name：字符串。序列普遍的名称&#x2F;id，有时候与 Accession 号相同，在 Genbank 中类似于 LOCUS id</li>
<li>.description：字符串。人们容易理解的序列的名称与信息。</li>
<li>.letter_annotations ：字典。序列中每个字母的额外信息，如碱基质量值或者二级结构等。键是这些额外信息的名称，信息作为与序列本身相同长度的Python序列（列表、元组或字符串）储存在值中</li>
<li>.annotations：字典。储存了该序列的附加信息。键是信息的名称，信息储存在值中。这允许在序列中添加更多的“非结构化”信息</li>
<li>.features：由 SeqFeature 类对象组成的列表。储存该序列更多的结构化信息。（如：基因组上的基因位置、蛋白质序列上的结构域）</li>
<li>.dbxrefs：作为字符串的数据库交叉引用的列表。</li>
</ul>
<h3 id="4-2-创建-Seqrecord-对象"><a href="#4-2-创建-Seqrecord-对象" class="headerlink" title="4.2 创建 Seqrecord 对象"></a>4.2 创建 Seqrecord 对象</h3><h4 id="4-2-1-手动创建简单的-SeqRecord-对象"><a href="#4-2-1-手动创建简单的-SeqRecord-对象" class="headerlink" title="4.2.1 手动创建简单的 SeqRecord 对象"></a>4.2.1 手动创建简单的 SeqRecord 对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.2.1 手动构建简单的SeqRecord对象</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"><span class="keyword">from</span> Bio.SeqRecord <span class="keyword">import</span> SeqRecord</span><br><span class="line"></span><br><span class="line">simple_seq = Seq(<span class="string">&#x27;ACGT&#x27;</span>)</span><br><span class="line">simple_seq_r = SeqRecord(simple_seq,<span class="built_in">id</span>=<span class="string">&#x27;AC1001&#x27;</span>) <span class="comment">#不添加其它属性，默认unknown</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_record:\n\n <span class="subst">&#123;simple_seq_r&#125;</span> \n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_id: <span class="subst">&#123;simple_seq_r.<span class="built_in">id</span> &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq: <span class="subst">&#123;simple_seq_r.seq &#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_description: <span class="subst">&#123;simple_seq_r.description &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加其它属性</span></span><br><span class="line">simple_seq_r.description = <span class="string">&#x27;A simple seq&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_description: <span class="subst">&#123;simple_seq_r.description &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">simple_seq_r.annotations[<span class="string">&#x27;Evidence&#x27;</span>] = <span class="string">&#x27;None, I just made it up&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_annotations: <span class="subst">&#123;simple_seq_r.annotations[<span class="string">&quot;Evidence&quot;</span>] &#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">simple_seq_r.letter_annotations[<span class="string">&#x27;phred_quality&#x27;</span>] = [<span class="number">39</span>,<span class="number">39</span>,<span class="number">38</span>,<span class="number">37</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;seq_letter_annotations: <span class="subst">&#123;simple_seq_r.letter_annotations[<span class="string">&quot;phred_quality&quot;</span>] &#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-FASTA-文件中的-SeqRecord-对象"><a href="#4-2-2-FASTA-文件中的-SeqRecord-对象" class="headerlink" title="4.2.2 FASTA 文件中的 SeqRecord 对象"></a>4.2.2 FASTA 文件中的 SeqRecord 对象</h4><p>FASTA 文件中，第一行，去除 <code>&gt;</code> 号，最后一个 <code>|</code> 之前的所有字符为 id 属性与 name 属性（包括最后1个<code>|</code>），后面的所有内容均属于 description 属性。FASTA 文件中，annotations、features等属性均为空。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.2.2 FASTA 文件中的 SeqRecord 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment">#只有1条记录时使用 Bio 模块的 SeqIO 模块即可读取</span></span><br><span class="line">seq_r = SeqIO.read(<span class="string">&quot;NC_005816.fasta&quot;</span>,<span class="string">&#x27;fasta&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_r,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_r.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_r.name)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-Genbank-文件中的-SeqRecord-对象"><a href="#4-2-3-Genbank-文件中的-SeqRecord-对象" class="headerlink" title="4.2.3 Genbank 文件中的 SeqRecord 对象"></a>4.2.3 Genbank 文件中的 SeqRecord 对象</h4><p>id 属性来自 VERSION 行，name 属性来自 LOCUS 行，description 属性来自 DEFINITION 行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.2.3 Genbank 文件中的 SeqRecord 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">seq_r = SeqIO.read(<span class="string">&quot;AE017046.gb&quot;</span>,<span class="string">&#x27;genbank&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_r.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_r.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(seq_r.annotations))</span><br><span class="line"><span class="built_in">print</span>(seq_r.annotations[<span class="string">&#x27;source&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(seq_r.letter_annotations)</span><br><span class="line"><span class="built_in">print</span>(seq_r.dbxrefs)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(seq_r.features))</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Feature-location-position-对象"><a href="#4-3-Feature-location-position-对象" class="headerlink" title="4.3 Feature,location,position 对象"></a>4.3 Feature,location,position 对象</h3><h4 id="4-3-1-SeqFeature-对象"><a href="#4-3-1-SeqFeature-对象" class="headerlink" title="4.3.1 SeqFeature 对象"></a>4.3.1 SeqFeature 对象</h4><p>每个 SeqFeature 对象的关键思想是描述了父序列上的一个区域，通常是一个SeqRecord对象。SeqFeature对象的属性：</p>
<ul>
<li>.type：对 feature 的文本描述，如 CDS、gene</li>
<li>.location：当前 SeqFeature 对应的坐标<ul>
<li>.ref</li>
<li>.ref_db</li>
<li>.strand：1 正链；-1 负链；0 未知；None 无关紧要（蛋白与单链序列均为 None）</li>
</ul>
</li>
<li>.qualifiers：字典。存储额外信息</li>
<li>.sub_features。对于一些复杂的 feature 如通过 join 连接的，不过目前已经引入了 CompoundLocation 对象所以可以忽略该属性。</li>
</ul>
<h4 id="4-3-2-Position-和-Location"><a href="#4-3-2-Position-和-Location" class="headerlink" title="4.3.2 Position 和 Location"></a>4.3.2 Position 和 Location</h4><ul>
<li>position：代表序列的位置，可以是明确的或者模糊的，如 5，20，100，&gt;50，&lt;100</li>
<li>location：由 positions 界定出的区间，如 5..20</li>
</ul>
<h5 id="4-3-2-1-SimpleLocation-对象"><a href="#4-3-2-1-SimpleLocation-对象" class="headerlink" title="4.3.2.1 SimpleLocation 对象"></a>4.3.2.1 SimpleLocation 对象</h5><p>除非是真核生物基因，否则大部分 SeqFeatures 的 location 都是简单的</p>
<h5 id="4-3-2-2-CompoundLocation-对象"><a href="#4-3-2-2-CompoundLocation-对象" class="headerlink" title="4.3.2.2 CompoundLocation 对象"></a>4.3.2.2 CompoundLocation 对象</h5><p>主要用于处理 EMBL&#x2F;Genbank 文件中的 ‘join’ location</p>
<h5 id="4-3-2-3-Fuzzy-positions"><a href="#4-3-2-3-Fuzzy-positions" class="headerlink" title="4.3.2.3 Fuzzy positions"></a>4.3.2.3 Fuzzy positions</h5><p>生物学中，position经常会不明确，定义了 5种类：</p>
<ul>
<li>ExactPosition：明确的位置</li>
<li>BeforePosition：例如 BeforePosition(13) 代表实际位置位于 &lt;13 的位置</li>
<li>AfterPosition：例如 AfterPosition(13) 代表实际位置位于 &gt;13 的位置</li>
<li>WithinPosition：模拟在两个特定核苷酸之间的位置，如 ‘(1.5)’，代表处于 1-5 之间</li>
<li>OneOfPosition</li>
<li>UnknownPosition</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqFeature</span><br><span class="line"></span><br><span class="line">start_position = SeqFeature.AfterPosition(<span class="number">5</span>)</span><br><span class="line">end_position = SeqFeature.BetweenPosition(<span class="number">9</span>,left=<span class="number">8</span>,right=<span class="number">9</span>)</span><br><span class="line">my_location = SeqFeature.SimpleLocation(start_position,end_position)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_location)</span><br><span class="line"><span class="built_in">print</span>(my_location.start)</span><br><span class="line"><span class="built_in">print</span>(my_location.end)</span><br><span class="line"><span class="built_in">print</span>(my_location.strand)</span><br><span class="line"></span><br><span class="line"><span class="comment">#当不想要 fuzzy position，想要确切的位置时，可以转换为整型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(my_location.start))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(my_location.end))</span><br><span class="line"><span class="comment">#或者直接传递整数</span></span><br><span class="line">exact_location = SeqFeature.SimpleLocation(<span class="number">5</span>,<span class="number">9</span>)</span><br><span class="line"><span class="built_in">print</span>(exact_location)</span><br><span class="line"><span class="built_in">print</span>(exact_location.start)</span><br><span class="line"><span class="built_in">print</span>(exact_location.end)</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-4-Location-测试"><a href="#4-3-2-4-Location-测试" class="headerlink" title="4.3.2.4 Location 测试"></a>4.3.2.4 Location 测试</h5><p>查找某个 SNP 坐标在哪个 feature&#x2F;location</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record = SeqIO.read(<span class="string">&quot;AE017046.gb&quot;</span>,<span class="string">&#x27;genbank&#x27;</span>)</span><br><span class="line">my_snp = <span class="number">8088</span></span><br><span class="line"><span class="keyword">for</span> feature <span class="keyword">in</span> record.features:</span><br><span class="line">    <span class="keyword">if</span> my_snp <span class="keyword">in</span> feature:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;feature.<span class="built_in">type</span>&#125;</span> <span class="subst">&#123;feature.qualifiers&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(f&#x27;&#123;feature.type&#125; &#123;feature.qualifiers.get(&quot;db_xref&quot;)&#125;&#x27;)</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-由1个-feature-或-location-所描述的-Sequence"><a href="#4-3-3-由1个-feature-或-location-所描述的-Sequence" class="headerlink" title="4.3.3 由1个 feature 或 location 所描述的 Sequence"></a>4.3.3 由1个 feature 或 location 所描述的 Sequence</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"><span class="keyword">from</span> Bio.SeqFeature <span class="keyword">import</span> SeqFeature,SimpleLocation</span><br><span class="line"></span><br><span class="line">seq = Seq(<span class="string">&#x27;ACCGAGACGGCAAAGGCTAGCATAGGTATGAGACTTCCTTCCTGCCAGTGCTGAGGAACTGGGAGCCTAC&#x27;</span>)</span><br><span class="line">feature = SeqFeature(SimpleLocation(<span class="number">5</span>,<span class="number">18</span>,strand=-<span class="number">1</span>),<span class="built_in">type</span>=<span class="string">&#x27;gene&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取 feature 对应的序列</span></span><br><span class="line">feature_seq = seq[feature.location.start:feature.location.end].reverse_complement()</span><br><span class="line"><span class="built_in">print</span>(feature_seq)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接使用 extract 方法提取，与上面语句等价</span></span><br><span class="line">feature_seq1 = feature.extract(seq)</span><br><span class="line"><span class="built_in">print</span>(feature_seq1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#SeqFeature 或 location 的长度与其对应的序列长度一致</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(feature_seq), <span class="built_in">len</span>(feature), <span class="built_in">len</span>(feature.location))</span><br></pre></td></tr></table></figure>

<h3 id="4-4-比较"><a href="#4-4-比较" class="headerlink" title="4.4 比较"></a>4.4 比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.4 两个 SeqRecord对象比较</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"><span class="keyword">from</span> Bio.SeqRecord <span class="keyword">import</span> SeqRecord</span><br><span class="line"></span><br><span class="line">seq_record1 = SeqRecord(Seq(<span class="string">&#x27;AGCT&#x27;</span>),<span class="built_in">id</span>=<span class="string">&#x27;A001&#x27;</span>)</span><br><span class="line">seq_record2 = SeqRecord(Seq(<span class="string">&#x27;AGCT&#x27;</span>),<span class="built_in">id</span>=<span class="string">&#x27;A001&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(seq_record1 == seq_record2)</span></span><br><span class="line"><span class="built_in">print</span>(seq_record1.<span class="built_in">id</span> == seq_record2.<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(seq_record1.seq == seq_record2.seq)</span><br></pre></td></tr></table></figure>

<h3 id="4-5-引用"><a href="#4-5-引用" class="headerlink" title="4.5 引用"></a>4.5 引用</h3><p>另一种常见的注释是对期刊或出版物的引用，Bio.SeqFeature 模块的 Reference 类可以储存这种信息。任何 reference 对象都储存在1个列表中，然后作为 SeqRecord 的 annotations 属性的 references 键对应的值进行储存。</p>
<h3 id="4-6-format-方法"><a href="#4-6-format-方法" class="headerlink" title="4.6 format 方法"></a>4.6 format 方法</h3><p>SeqRecord 类的 format 方法可以生成一个字符串，把 SeqRecord 对象中记录的信息转换为支持 SeqIO 接口输出的格式，如 FASTA</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.6 format 方法</span></span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"><span class="keyword">from</span> Bio.SeqRecord <span class="keyword">import</span> SeqRecord</span><br><span class="line"></span><br><span class="line">record = SeqRecord(Seq(<span class="string">&#x27;AAATTTCCCGGGATCGATCGATCG&#x27;</span>),</span><br><span class="line">                   <span class="built_in">id</span>=<span class="string">&#x27;AC001&#x27;</span>,</span><br><span class="line">                   description=<span class="string">&#x27;This is an example&#x27;</span>)</span><br><span class="line">record_fna_format = record.<span class="built_in">format</span>(<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(record_fna_format)</span><br></pre></td></tr></table></figure>

<h3 id="4-7-对-SeqRecord-进行切片"><a href="#4-7-对-SeqRecord-进行切片" class="headerlink" title="4.7 对 SeqRecord 进行切片"></a>4.7 对 SeqRecord 进行切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.7 SeqRecord切片</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record = SeqIO.read(<span class="string">&quot;AE017046.gb&quot;</span>,<span class="string">&#x27;genbank&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(record))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(record.features))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接阅读 gb文件，发现 pim 基因，YP_pPCP05 (4343..4780 -&gt; python 4342:4780)</span></span><br><span class="line"><span class="comment"># 数一下，发现在第 11、12 feature</span></span><br><span class="line"><span class="built_in">print</span>(record.features[<span class="number">11</span>].location)</span><br><span class="line"><span class="built_in">print</span>(record.features[<span class="number">12</span>].location)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 4300:4800 进行切片，以完全覆盖 pim 基因</span></span><br><span class="line">sub_record = record[<span class="number">4300</span>:<span class="number">4800</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(sub_record), <span class="built_in">len</span>(sub_record.features)) <span class="comment">#仅2个 features</span></span><br><span class="line"><span class="built_in">print</span>(sub_record.features[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub_record 会保留一些信息，但有些信息继承以后可能是错的</span></span><br><span class="line"><span class="built_in">print</span>(sub_record.description)</span><br><span class="line">sub_record.description = <span class="string">&#x27;Yersinia pestis biovar Microtus str. 91001 plasmid pPCP1, partial&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(sub_record.description)</span><br><span class="line"><span class="built_in">print</span>(sub_record.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将子序列转换为 genbank 格式</span></span><br><span class="line">sub_record_gb = sub_record.<span class="built_in">format</span>(<span class="string">&quot;genbank&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sub_record_gb[:<span class="number">200</span>] + <span class="string">&#x27;...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-8-合并-SeqRecord-对象"><a href="#4-8-合并-SeqRecord-对象" class="headerlink" title="4.8 合并 SeqRecord 对象"></a>4.8 合并 SeqRecord 对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.8 合并 SeqRecord 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record = <span class="built_in">next</span>(SeqIO.parse(<span class="string">&quot;example.fastq&quot;</span>,<span class="string">&#x27;fastq&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(record))</span><br><span class="line"><span class="built_in">print</span>(record.letter_annotations)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接通过+号合并</span></span><br><span class="line">left = record[:<span class="number">20</span>]</span><br><span class="line">right = record[<span class="number">20</span>:]</span><br><span class="line">new_record = left + right</span><br><span class="line"><span class="built_in">print</span>(record.seq == new_record.seq)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取genbank序列</span></span><br><span class="line">record = SeqIO.read(<span class="string">&quot;AE017046.gb&quot;</span>,<span class="string">&#x27;genbank&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(record.dbxrefs)</span><br><span class="line"><span class="built_in">print</span>(record.annotations.keys())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(record))</span><br><span class="line"></span><br><span class="line">new_record = record[:<span class="number">4500</span>] + record[<span class="number">4500</span>:]</span><br><span class="line"><span class="built_in">print</span>(new_record.dbxrefs) <span class="comment"># 合并后 dfxrefs 属性没有了，这是因为SeqRecord切片步骤在保留注释方面非常谨慎（错误地传递注释可能会导致重大问题）</span></span><br><span class="line"><span class="built_in">print</span>(new_record.annotations.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要手动添加注释</span></span><br><span class="line">new_record.dbxrefs = record.dbxrefs[:]</span><br><span class="line">new_record.annotations = record.annotations.copy()</span><br><span class="line"><span class="built_in">print</span>(new_record.dbxrefs) </span><br><span class="line"><span class="built_in">print</span>(new_record.annotations.keys())</span><br></pre></td></tr></table></figure>

<h3 id="4-9-对-SeqRecord-对象进行反向互补"><a href="#4-9-对-SeqRecord-对象进行反向互补" class="headerlink" title="4.9 对 SeqRecord 对象进行反向互补"></a>4.9 对 SeqRecord 对象进行反向互补</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4.9 对 SeqRecord 对象进行反向互补</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record = SeqIO.read(<span class="string">&quot;AE017046.gb&quot;</span>,<span class="string">&#x27;genbank&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(record.<span class="built_in">id</span>,<span class="built_in">len</span>(record),<span class="built_in">len</span>(record.features),<span class="built_in">len</span>(record.dbxrefs),<span class="built_in">len</span>(record.annotations))</span><br><span class="line"><span class="built_in">print</span>(record.seq[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">new_record = record.reverse_complement(<span class="built_in">id</span>=<span class="string">&quot;TESTING&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_record.<span class="built_in">id</span>,<span class="built_in">len</span>(record),<span class="built_in">len</span>(new_record.features),<span class="built_in">len</span>(new_record.dbxrefs),<span class="built_in">len</span>(new_record.annotations))</span><br><span class="line"><span class="built_in">print</span>(new_record.seq[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure>

<h2 id="5-序列-Input-Output"><a href="#5-序列-Input-Output" class="headerlink" title="5. 序列 Input&#x2F;Output"></a>5. 序列 Input&#x2F;Output</h2><h3 id="5-1-解析或读取序列"><a href="#5-1-解析或读取序列" class="headerlink" title="5.1 解析或读取序列"></a>5.1 解析或读取序列</h3><p>Bio.SeqIO.parse() 函数将序列数据进行解析，储存为 SeqRecord 对象。该函数需要2个参数，第 1 个参数指明文件来源，可以是本地文件名，也可以是网址，也可以是命令行程序的输出结果，第 2 个参数指明文件类型。Bio.SeqIO.parse() 函数解析后返回的是 1 个迭代器，常结合 for 循环使用。</p>
<ul>
<li>函数解析的文件类型：<a target="_blank" rel="noopener" href="https://biopython.org/wiki/SeqIO">https://biopython.org/wiki/SeqIO</a> 以及 build in 文档 ：<a target="_blank" rel="noopener" href="https://biopython.org/docs/1.82/api/Bio.SeqIO.html">https://biopython.org/docs/1.82/api/Bio.SeqIO.html</a></li>
</ul>
<p>如果仅有 1 条序列，使用 Bio.SeqIO.read() 函数即可直接读取</p>
<h4 id="5-1-1-读取-Sequence-文件"><a href="#5-1-1-读取-Sequence-文件" class="headerlink" title="5.1.1 读取 Sequence 文件"></a>5.1.1 读取 Sequence 文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 5.1.1 读取 Sequence 文件</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(seq_record.<span class="built_in">id</span>,<span class="built_in">len</span>(seq_record))</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以直接解析到列表中</span></span><br><span class="line">seq_list = [seq_record.<span class="built_in">id</span> <span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.gbk&quot;</span>,<span class="string">&quot;genbank&quot;</span>)]</span><br><span class="line"><span class="built_in">print</span>(seq_list)</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-迭代序列文件中的记录"><a href="#5-1-2-迭代序列文件中的记录" class="headerlink" title="5.1.2 迭代序列文件中的记录"></a>5.1.2 迭代序列文件中的记录</h4><p>只有迭代器对象才能与内置函数 <code>next</code> 结合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.1.2 迭代序列文件中的记录</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record_iterator = SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">first_record = <span class="built_in">next</span>(record_iterator)</span><br><span class="line"><span class="built_in">print</span>(first_record.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line">second_record = <span class="built_in">next</span>(record_iterator)</span><br><span class="line"><span class="built_in">print</span>(second_record.<span class="built_in">id</span>)</span><br><span class="line"><span class="comment">#如果迭代器中没有下一条记录，next函数会出现迭代异常</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-获取由序列对象组成的列表"><a href="#5-1-3-获取由序列对象组成的列表" class="headerlink" title="5.1.3 获取由序列对象组成的列表"></a>5.1.3 获取由序列对象组成的列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.1.3 获取由序列对象组成的列表</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">record_list = <span class="built_in">list</span>(SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(record_list[-<span class="number">1</span>].<span class="built_in">id</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">repr</span>(record_list[-<span class="number">1</span>].seq)) <span class="comment"># repr函数将对象转换为供解释器读取的形式</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-提取数据"><a href="#5-1-4-提取数据" class="headerlink" title="5.1.4 提取数据"></a>5.1.4 提取数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.1.4 提取数据</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取 genbank 文件中每条序列的 organism 对应的物种信息</span></span><br><span class="line">record_list = [seq_record.annotations[<span class="string">&quot;organism&quot;</span>] </span><br><span class="line">               <span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.gbk&quot;</span>,<span class="string">&quot;genbank&quot;</span>)]</span><br><span class="line"><span class="built_in">print</span>(record_list)</span><br><span class="line"></span><br><span class="line"><span class="comment">#提取 fasta 文件中每条序列的 description 信息中的第1个短语</span></span><br><span class="line">record_list = [seq_record.description.split()[<span class="number">1</span>] </span><br><span class="line">               <span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>)]</span><br><span class="line"><span class="built_in">print</span>(record_list)</span><br></pre></td></tr></table></figure>

<h4 id="5-1-5-修饰数据"><a href="#5-1-5-修饰数据" class="headerlink" title="5.1.5 修饰数据"></a>5.1.5 修饰数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 5.1.5 修饰数据</span></span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接更改其属性即可</span></span><br><span class="line">seq_records = SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">first_record = <span class="built_in">next</span>(seq_records)</span><br><span class="line">first_record.<span class="built_in">id</span> = <span class="string">&quot;New_id&quot;</span></span><br><span class="line">first_record.description = <span class="string">&quot;This is a new description&quot;</span></span><br><span class="line"><span class="built_in">print</span>(first_record.<span class="built_in">format</span>(<span class="string">&quot;fasta&quot;</span>)[:<span class="number">200</span>])</span><br></pre></td></tr></table></figure>

<h3 id="5-2-从压缩文件中解析序列"><a href="#5-2-从压缩文件中解析序列" class="headerlink" title="5.2 从压缩文件中解析序列"></a>5.2 从压缩文件中解析序列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ls_orchid.gbk&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">len</span>(<span class="built_in">id</span>) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> SeqIO.parse(handle,<span class="string">&quot;gb&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">with</span> gzip.<span class="built_in">open</span>(<span class="string">&quot;ls_orchid.gbk.gz&quot;</span>,<span class="string">&quot;rt&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">len</span>(<span class="built_in">id</span>) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> SeqIO.parse(handle,<span class="string">&quot;gb&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bz2</span><br><span class="line"><span class="keyword">with</span> bz2.<span class="built_in">open</span>(<span class="string">&quot;ls_orchid.gbk.bz2&quot;</span>,<span class="string">&quot;rt&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">len</span>(<span class="built_in">id</span>) <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> SeqIO.parse(handle,<span class="string">&quot;genbank&quot;</span>)))</span><br></pre></td></tr></table></figure>

<h3 id="5-3-从网上获取序列"><a href="#5-3-从网上获取序列" class="headerlink" title="5.3 从网上获取序列"></a>5.3 从网上获取序列</h3><h4 id="5-3-1-在线获取-genbank-序列"><a href="#5-3-1-在线获取-genbank-序列" class="headerlink" title="5.3.1 在线获取 genbank 序列"></a>5.3.1 在线获取 genbank 序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取一条记录</span></span><br><span class="line">Entrez.email = <span class="string">&quot;1033579227@qq.com&quot;</span></span><br><span class="line"><span class="keyword">with</span> Entrez.efetch(db=<span class="string">&quot;nucleotide&quot;</span>,rettype=<span class="string">&quot;fasta&quot;</span>,retmode=<span class="string">&quot;text&quot;</span>,<span class="built_in">id</span>=<span class="string">&quot;6273291&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    seq_record = SeqIO.read(handle,<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(seq_record)</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取多条记录</span></span><br><span class="line">Entrez.email = <span class="string">&quot;1033579227@qq.com&quot;</span></span><br><span class="line"><span class="keyword">with</span> Entrez.efetch(db=<span class="string">&quot;nucleotide&quot;</span>,rettype=<span class="string">&quot;gb&quot;</span>,retmode=<span class="string">&quot;text&quot;</span>,<span class="built_in">id</span>=<span class="string">&quot;6273291,6273290,6273289&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> SeqIO.parse(handle,<span class="string">&quot;gb&quot;</span>):</span><br><span class="line">        <span class="built_in">print</span>(record.annotations[<span class="string">&quot;source&quot;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="5-3-2-在线获取-Swissprot-序列"><a href="#5-3-2-在线获取-Swissprot-序列" class="headerlink" title="5.3.2 在线获取 Swissprot 序列"></a>5.3.2 在线获取 Swissprot 序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> ExPASy</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取一条记录</span></span><br><span class="line"><span class="keyword">with</span> ExPASy.get_sprot_raw(<span class="string">&quot;O23729&quot;</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    seq_record = SeqIO.read(handle,<span class="string">&quot;swiss&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(seq_record)</span><br></pre></td></tr></table></figure>

<h3 id="5-4-序列文件作为字典"><a href="#5-4-序列文件作为字典" class="headerlink" title="5.4 序列文件作为字典"></a>5.4 序列文件作为字典</h3><p>通过对 SeqIO.parse 解析返回的迭代器进行循环后会耗尽文件资源。对于自引文件，例如 twoBit 格式的文件，通过 SeqIO.parse 解析后返回的值可以作为字典使用，即允许对序列内容的随机访问。能随机访问的前提是文件已经被打开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">handle = <span class="built_in">open</span>(<span class="string">&#x27;./sequence.bigendian.2bit&#x27;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">records = SeqIO.parse(handle,<span class="string">&quot;twobit&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(records.keys())</span><br><span class="line"><span class="built_in">print</span>(records[<span class="string">&quot;seq222&quot;</span>].seq)</span><br><span class="line">handle.close()</span><br><span class="line"><span class="built_in">print</span>(records.keys())</span><br><span class="line"><span class="built_in">print</span>(records[<span class="string">&quot;seq222&quot;</span>].seq) <span class="comment">#会报错</span></span><br></pre></td></tr></table></figure>

<p>对于其他文件格式来说，Bio.SeqIO 提供了三个相关的功能函数，允许我们像字典一样随机访问一个多序列文件。在这里，在灵活性和内存使用之间存在一种权衡。简而言之：</p>
<ul>
<li>Bio.SeqIO.to_dict() 最灵活但也最耗内存。每个序列都在内存中储存为 SeqRecord 对象，可对这些对象进行编辑。</li>
<li>Bio.SeqIO.index() 中等灵活，可得到 1 个仅供读取的字典，可在有需要时把序列解析为 SeqRecord 对象</li>
<li>Bio.SeqIO.index_db() 得到仅供读取的字典，同时把 identifiers 储存在硬盘上 1 个单独的文件中（作为 1 个 SQLite3 数据库）。也就是说仅需要少量内存，但速度也更慢。</li>
</ul>
<h4 id="5-4-1-序列文件作为字典（in-memory）"><a href="#5-4-1-序列文件作为字典（in-memory）" class="headerlink" title="5.4.1 序列文件作为字典（in memory）"></a>5.4.1 序列文件作为字典（in memory）</h4><p>把序列先读取为字典，再将其作为数据库引用检索的内容，这对于大型文件来说非常有用，可以快速获得想要的元素。Bio.SeqIO.to_dict() 函数默认以序列的 identifier（即 .id 属性）作为字典的键。（不过需要注意会耗费大量内存）</p>
<h5 id="5-4-1-1-自定义字典的键"><a href="#5-4-1-1-自定义字典的键" class="headerlink" title="5.4.1.1 自定义字典的键"></a>5.4.1.1 自定义字典的键</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接读取为字典，键默认为 identifier </span></span><br><span class="line">orchid_dict = SeqIO.to_dict(SeqIO.parse(<span class="string">&quot;./ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(orchid_dict.keys())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义自定义字典键的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_accession</span>(<span class="params">record</span>):</span><br><span class="line">    parts = record.<span class="built_in">id</span>.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(parts) == <span class="number">5</span> <span class="keyword">and</span> parts[<span class="number">0</span>] == <span class="string">&quot;gi&quot;</span> <span class="keyword">and</span> parts[<span class="number">2</span>] == <span class="string">&quot;emb&quot;</span></span><br><span class="line">    <span class="keyword">return</span> parts[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字典的键</span></span><br><span class="line">orchid_dict = SeqIO.to_dict(SeqIO.parse(<span class="string">&quot;./ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>),</span><br><span class="line">                            key_function=get_accession)</span><br><span class="line"><span class="built_in">print</span>(orchid_dict.keys())</span><br></pre></td></tr></table></figure>

<h5 id="5-4-1-2-使用-SEGUID-checksum-对字典进行索引"><a href="#5-4-1-2-使用-SEGUID-checksum-对字典进行索引" class="headerlink" title="5.4.1.2 使用 SEGUID checksum 对字典进行索引"></a>5.4.1.2 使用 SEGUID checksum 对字典进行索引</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">from</span> Bio.SeqUtils.CheckSum <span class="keyword">import</span> seguid</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> record <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;./ls_orchid.gbk&quot;</span>,<span class="string">&quot;gb&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(record.<span class="built_in">id</span>,seguid(record.seq))</span><br><span class="line"></span><br><span class="line">orchid_dict = SeqIO.to_dict(</span><br><span class="line">    SeqIO.parse(<span class="string">&quot;./ls_orchid.gbk&quot;</span>,<span class="string">&quot;gb&quot;</span>),<span class="keyword">lambda</span> <span class="built_in">id</span>:seguid(<span class="built_in">id</span>.seq))</span><br><span class="line"></span><br><span class="line">record = orchid_dict[<span class="string">&quot;H+JfaShya/4yyAj7IbMqgNkxdxQ&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(record.<span class="built_in">id</span>,record.description)</span><br></pre></td></tr></table></figure>

<h4 id="5-4-2-序列文件作为字典（index-file"><a href="#5-4-2-序列文件作为字典（index-file" class="headerlink" title="5.4.2 序列文件作为字典（index file)"></a>5.4.2 序列文件作为字典（index file)</h4><p>适用于更大型的文件。不支持 PHYLIP 或 clustal 等序列比对格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接读取为字典，键默认为 identifier </span></span><br><span class="line">orchid_dict = SeqIO.index(<span class="string">&quot;./ls_orchid.gbk&quot;</span>,<span class="string">&quot;gb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(orchid_dict))</span><br><span class="line"><span class="built_in">print</span>(orchid_dict[<span class="string">&quot;Z78439.1&quot;</span>].<span class="built_in">id</span>)</span><br><span class="line">orchid_dict.close()</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-1-自定义字典的键"><a href="#5-4-2-1-自定义字典的键" class="headerlink" title="5.4.2.1 自定义字典的键"></a>5.4.2.1 自定义字典的键</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义自定义字典键的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_accession</span>(<span class="params">record_id</span>):</span><br><span class="line">    parts = record_id.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(parts) == <span class="number">5</span> <span class="keyword">and</span> parts[<span class="number">0</span>] == <span class="string">&quot;gi&quot;</span> <span class="keyword">and</span> parts[<span class="number">2</span>] == <span class="string">&quot;emb&quot;</span></span><br><span class="line">    <span class="keyword">return</span> parts[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义字典的键</span></span><br><span class="line">orchid_dict = SeqIO.index(<span class="string">&quot;./ls_orchid.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>,</span><br><span class="line">                            key_function=get_accession)</span><br><span class="line"><span class="built_in">print</span>(orchid_dict.keys())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(orchid_dict.keys()))</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-2-从-1-个-record-中获取原始数据"><a href="#5-4-2-2-从-1-个-record-中获取原始数据" class="headerlink" title="5.4.2.2 从 1 个 record 中获取原始数据"></a>5.4.2.2 从 1 个 record 中获取原始数据</h5><p>来自 Bio.SeqIO.index() 中的类似字典的对象给了我们 1个通向每个 SeqRecord 对象的入口。但是，有时能够直接从文件中获取原始原始数据是很有用的。为此，可以使用 get_raw() 方法，该方法接受单个参数（identifier），并返回一个字节字符串（从文件中提取，不进行修改）</p>
<p>一个例子是从一个大文件中提取一个记录的子集。可用于 Bio.SeqIO.write()（目前）不支持输出的文件格式（例如纯文本SwissProt文件格式）或需要准确保存文本的地方（例如GenBank或EMBL 从 biopython 输出还无法保留 annotation 的最后 1 个字节）。</p>
<p>下载<a target="_blank" rel="noopener" href="https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.dat.gz">数据</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">uniprot = SeqIO.index(<span class="string">&quot;./uniprot_sprot.dat&quot;</span>,<span class="string">&quot;swiss&quot;</span>)</span><br><span class="line"><span class="comment"># python3 中需要以二进制模式写入因为 get_raw() 函数返回的是字节字符串</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;selected.dat&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> out_handle:</span><br><span class="line">    <span class="keyword">for</span> acc <span class="keyword">in</span> [<span class="string">&quot;P33487&quot;</span>, <span class="string">&quot;P19801&quot;</span>, <span class="string">&quot;P13689&quot;</span>, <span class="string">&quot;Q8JZQ5&quot;</span>, <span class="string">&quot;Q9TRC7&quot;</span>]:</span><br><span class="line">        out_handle.write(uniprot.get_raw(acc))</span><br></pre></td></tr></table></figure>

<h4 id="5-4-3-序列文件作为字典（Database-indexed-files"><a href="#5-4-3-序列文件作为字典（Database-indexed-files" class="headerlink" title="5.4.3 序列文件作为字典（Database indexed files)"></a>5.4.3 序列文件作为字典（Database indexed files)</h4><p>下载<a target="_blank" rel="noopener" href="https://ftp.ncbi.nlm.nih.gov/genbank/">部分病毒 genbank 数据</a>并解压：gbvrl1.seq.gz</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment">#glob是实用的文件名匹配库，glob.glob()函数将会匹配给定路径下的所有pattern，并以列表形式返回。</span></span><br><span class="line">files = glob.glob(<span class="string">&quot;gbvrl*.seq&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">len</span>(files)&#125;</span> files to index&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gb_vrl = SeqIO.index_db(<span class="string">&quot;gbvrl.idx&quot;</span>,files,<span class="string">&quot;genbank&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">len</span>(gb_vrl)&#125;</span> files indexed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#构建完索引后可快速加载</span></span><br><span class="line"><span class="built_in">print</span>(gb_vrl[<span class="string">&#x27;AB811634.1&#x27;</span>].description)</span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-1-从-1-个-record-获取原始数据"><a href="#5-4-3-1-从-1-个-record-获取原始数据" class="headerlink" title="5.4.3.1 从 1 个 record 获取原始数据"></a>5.4.3.1 从 1 个 record 获取原始数据</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(gb_vrl.get_raw(<span class="string">&quot;AB811634.1&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="5-4-4-索引压缩文件"><a href="#5-4-4-索引压缩文件" class="headerlink" title="5.4.4 索引压缩文件"></a>5.4.4 索引压缩文件</h4><p>你经常会索引 1 个大型文件，所以通常想要压缩它。不幸的是对于常见的 gzip 与 bzip2 文件的高效随机获取是比较困难的。这里，BGZF（Blocked GNU Zip Format）是非常有用的。这种格式是 gzip 的一种变体，可以使用 gzip 工具解压，在 bam 文件格式中非常受欢迎。本例中以 .bgz 后缀命名。</p>
<p>创建 1 个 BGZF 文件可以使用 samtools 中的 bgzip 工具。你可以使用 Bio.bgzf 模块在 python 中读写 BGZF 文件。</p>
<p>Bio.SeqIO.index() 与 Bio.SeqIO.index_db() 均可使用 BGZF 压缩文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过命令行工具压缩为 BGZF 文件 -c 代表保留源文件 </span></span><br><span class="line">bgzip -c ls_orchid.gbk &gt;ls_orchid.gbk.bgz</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">orchid_dict = SeqIO.index(<span class="string">&quot;./ls_orchid.gbk&quot;</span>,<span class="string">&quot;gb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(orchid_dict))</span><br><span class="line">orchid_dict.close()</span><br><span class="line"></span><br><span class="line">orchid_dict = SeqIO.index(<span class="string">&quot;./ls_orchid.gbk.bgz&quot;</span>,<span class="string">&quot;gb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(orchid_dict))</span><br><span class="line">orchid_dict.close()</span><br><span class="line"></span><br><span class="line">orchid_dict = SeqIO.index_db(<span class="string">&quot;./ls_orchid.gbk.bgz.idx&quot;</span>,<span class="string">&quot;./ls_orchid.gbk.bgz&quot;</span>,<span class="string">&quot;gb&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(orchid_dict))</span><br><span class="line">orchid_dict.close()</span><br></pre></td></tr></table></figure>

<h3 id="5-5-输出序列文件"><a href="#5-5-输出序列文件" class="headerlink" title="5.5 输出序列文件"></a>5.5 输出序列文件</h3><p>将 SeqRecord 对象储存到 1 个列表中，然后使用 SeqIO.write 函数输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio.SeqRecord <span class="keyword">import</span> SeqRecord</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">from</span> Bio.Seq <span class="keyword">import</span> Seq</span><br><span class="line"></span><br><span class="line">rec1 = SeqRecord(seq=Seq(<span class="string">&#x27;AAAAA&#x27;</span>),<span class="built_in">id</span>=<span class="string">&quot;AA&quot;</span>)</span><br><span class="line">rec2 = SeqRecord(seq=Seq(<span class="string">&#x27;TTTTT&#x27;</span>),<span class="built_in">id</span>=<span class="string">&quot;BB&quot;</span>)</span><br><span class="line">rec3 = SeqRecord(seq=Seq(<span class="string">&#x27;GGGGG&#x27;</span>),<span class="built_in">id</span>=<span class="string">&quot;CC&quot;</span>)</span><br><span class="line"></span><br><span class="line">recs = [rec1,rec2,rec3]</span><br><span class="line">SeqIO.write(recs,<span class="string">&quot;seqs.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-Round-trips"><a href="#5-5-1-Round-trips" class="headerlink" title="5.5.1 Round trips"></a>5.5.1 Round trips</h4><p>round trip，怎么读取文件，就原封不动写回去。SeqIO.write 模块无法做到，biopython 默认每行显示60字符。</p>
<p>以下面的例子为例，两个序列的碱基内容是一样的，但是换行的位置不同，这就不是 round trip 序列。</p>
<p>而且 biopython 不会保留文件的最后 1 个字节注释（Genbank 或 EMBL 格式），get_raw() 函数是其中 1 种解决方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;YAL068C-<span class="number">7235.2170</span> Putative promoter sequence</span><br><span class="line">TACGAGAATAATTTCTCATCATCCAGCTTTAACACAAAATTCGCACAGTTTTCGTTAAGA</span><br><span class="line">GAACTTAACATTTTCTTATGACGTAAATGAAGTTTATATATAAATTTCCTTTTTATTGGA</span><br><span class="line"></span><br><span class="line">&gt;YAL068C-<span class="number">7235.2170</span> Putative promoter sequence</span><br><span class="line">TACGAGAATAATTTCTCATCATCCAGCTTTAACACAAAATTCGCA</span><br><span class="line">CAGTTTTCGTTAAGAGAACTTAACATTTTCTTATGACGTAAATGA</span><br><span class="line">AGTTTATATATAAATTTCCTTTTTATTGGA</span><br></pre></td></tr></table></figure>

<h4 id="5-5-2-序列格式转换"><a href="#5-5-2-序列格式转换" class="headerlink" title="5.5.2 序列格式转换"></a>5.5.2 序列格式转换</h4><p>SeqIO.write 函数既接受列表输入又接受 SeqIO.parse 解析的迭代器作为输入，可以这样来实现格式转换。但是仍然有点复杂，因此 biopython 定义了一种新的函数来进行格式转换。</p>
<p>convert 函数可以接受句柄（handle）或者文件名作为输入，且理论上该函数可以转换任意 biopython 可解析的文件格式。不过需要注意有些文件需要额外的信息，例如 fastq 转换为 fasta。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">count = SeqIO.convert(<span class="string">&quot;ls_orchid.gbk&quot;</span>, <span class="string">&quot;genbank&quot;</span>, <span class="string">&quot;my_example.fasta&quot;</span>, <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Converted %i records&quot;</span> % count)</span><br></pre></td></tr></table></figure>

<h4 id="5-5-3-将序列文件输出为反向互补序列"><a href="#5-5-3-将序列文件输出为反向互补序列" class="headerlink" title="5.5.3 将序列文件输出为反向互补序列"></a>5.5.3 将序列文件输出为反向互补序列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="comment">#储存在列表中，占据系统内存</span></span><br><span class="line">records = [</span><br><span class="line">    rec.reverse_complement(<span class="built_in">id</span>=<span class="string">&quot;rc_&quot;</span> + rec.<span class="built_in">id</span>, description=<span class="string">&quot;reverse complement&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>, <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rec) &lt; <span class="number">700</span></span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(records))</span><br><span class="line"></span><br><span class="line"><span class="comment">#储存在迭代器中，不会把整个列表存入内存</span></span><br><span class="line">records = (</span><br><span class="line">    rec.reverse_complement(<span class="built_in">id</span>=<span class="string">&quot;rc_&quot;</span> + rec.<span class="built_in">id</span>, description=<span class="string">&quot;reverse complement&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> SeqIO.parse(<span class="string">&quot;ls_orchid.fasta&quot;</span>, <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(rec) &lt; <span class="number">700</span></span><br><span class="line">)</span><br><span class="line">SeqIO.write(records,<span class="string">&quot;rev_comp.fasta&quot;</span>,<span class="string">&quot;fasta&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="5-5-4-获取-SeqRecord-对象的格式化字符串"><a href="#5-5-4-获取-SeqRecord-对象的格式化字符串" class="headerlink" title="5.5.4 获取 SeqRecord 对象的格式化字符串"></a>5.5.4 获取 SeqRecord 对象的格式化字符串</h4><p>如果不打算把序列输出到文件或者句柄中。Bio.SeqIO 接口是基于句柄的，Python 有 1 个有用的内建函数可以提供基于句柄的字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line">records = SeqIO.parse(<span class="string">&quot;./ls_orchid.gbk&quot;</span>,<span class="string">&quot;gb&quot;</span>)</span><br><span class="line"></span><br><span class="line">out_handle = StringIO()</span><br><span class="line">SeqIO.write(records,out_handle,<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line">fasta_data = out_handle.getvalue()</span><br><span class="line"><span class="built_in">print</span>(fasta_data)</span><br></pre></td></tr></table></figure>

<p>上面的语句看起来没有那么直接，我们也可以直接通过 SeqRecord 模块的 format 方法输出格式化字符串，也可以将其写入文件中，但是需要注意对于 fasta、tab 等简单文件之外的复杂文件，还是建议用 SeqIO.write() 函数输出到文件中。</p>
<h3 id="5-6-低水平-FASTA-与-FASTQ-解析器"><a href="#5-6-低水平-FASTA-与-FASTQ-解析器" class="headerlink" title="5.6 低水平 FASTA 与 FASTQ 解析器"></a>5.6 低水平 FASTA 与 FASTQ 解析器</h3><p>考虑到速度问题，使用低水平 SimpleFastaParser 或者 FastqGeneralIterator 比使用 Bio.SeqIO.parse 对于高通量 FASTA 或者 FASTQ 序列文件更加实用。</p>
<p>当解析FASTA文件时，Bio.SeqIO.parse 调用内部的低水平 SimpleFastaParser 作为文件句柄。我们可以直接使用它，它遍历整个文件句柄，以包含两个字符串的元组来返回每一条记录：标题行（&gt;之后的所有内容）和序列（纯文本字符串格式）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解析 fasta</span></span><br><span class="line"><span class="keyword">from</span> Bio.SeqIO.FastaIO <span class="keyword">import</span> SimpleFastaParser</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">total_length = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./ls_orchid.fasta&quot;</span>) <span class="keyword">as</span> in_handle:</span><br><span class="line">    <span class="keyword">for</span> title,seq <span class="keyword">in</span> SimpleFastaParser(in_handle):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total_length += <span class="built_in">len</span>(seq)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test_seq.fasta&quot;</span>,<span class="string">&quot;a+&quot;</span>) <span class="keyword">as</span> out_handle:</span><br><span class="line">            out_handle.write(<span class="string">f&#x27;&gt;<span class="subst">&#123;title&#125;</span>\n<span class="subst">&#123;seq&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;count&#125;</span> records with total <span class="subst">&#123;total_length&#125;</span> sequence&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#解析 fastq(如果你不需要把碱基质量值转换为整数)</span></span><br><span class="line"><span class="keyword">from</span> Bio.SeqIO.QualityIO <span class="keyword">import</span> FastqGeneralIterator</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">total_length = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./example.fastq&quot;</span>) <span class="keyword">as</span> in_handle:</span><br><span class="line">    <span class="keyword">for</span> title,seq,quality <span class="keyword">in</span> FastqGeneralIterator(in_handle):</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total_length += <span class="built_in">len</span>(seq)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test_seq.fastq&quot;</span>,<span class="string">&quot;+a&quot;</span>) <span class="keyword">as</span> out_handle:</span><br><span class="line">            out_handle.write(<span class="string">f&#x27;@<span class="subst">&#123;title&#125;</span>\n<span class="subst">&#123;seq&#125;</span>\n+\n<span class="subst">&#123;quality&#125;</span>\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;count&#125;</span> records with total <span class="subst">&#123;total_length&#125;</span> sequence&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-序列比对"><a href="#6-序列比对" class="headerlink" title="6. 序列比对"></a>6. 序列比对</h2><h3 id="6-1-Alignment-对象"><a href="#6-1-Alignment-对象" class="headerlink" title="6.1 Alignment 对象"></a>6.1 Alignment 对象</h3><p>Bio.Align 模块中定义了 Alignment 类。通常我们可以从比对软件输出的结果或者 biopython pairwise aligner 输出获得的 Alignment 对象，不过这里我们先手动创建 1 个 Alignment 对象。</p>
<h4 id="6-1-1-从序列和坐标创建-1-个-Alignment-对象"><a href="#6-1-1-从序列和坐标创建-1-个-Alignment-对象" class="headerlink" title="6.1.1 从序列和坐标创建 1 个 Alignment 对象"></a>6.1.1 从序列和坐标创建 1 个 Alignment 对象</h4><p>这个数组代表的含义为：</p>
<ul>
<li>seqA[1:3] 分别与 seqB[0:2]、seqC[0:2] 比对上</li>
<li>seqA[3:4] 与 seqC[2:3] 比对上，seqB 为 gap</li>
<li>seqA[4:7] 分别与 seqB[2:5]、seqC[3:6] 比对上</li>
<li>seqA[7:9] 没有比对上的序列，seqB、seqC 在这两个位点为 gap</li>
<li>该比对不包含 seqA 的第一个核苷酸与 seqB 的最后两个核苷酸</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设有 3 条序列</span></span><br><span class="line">seqA = <span class="string">&#x27;CCGGTTTTT&#x27;</span></span><br><span class="line">seqB = <span class="string">&#x27;AGTTTAA&#x27;</span></span><br><span class="line">seqC = <span class="string">&#x27;AGGTTT&#x27;</span></span><br><span class="line">sequences = [seqA,seqB,seqC]</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到 Alignment 对象还需要坐标表面序列之间如何比对。这里使用 numpy 数组</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">coordinates = np.array([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Alignment 对象</span></span><br><span class="line"><span class="keyword">from</span> Bio.Align <span class="keyword">import</span> Alignment</span><br><span class="line">alignment = Alignment(sequences,coordinates)</span><br><span class="line"><span class="built_in">print</span>(alignment)</span><br><span class="line"><span class="built_in">print</span>(alignment.sequences)</span><br><span class="line"><span class="built_in">print</span>(alignment.coordinates)</span><br></pre></td></tr></table></figure>

<h4 id="6-1-2-从比对好的序列创建-Alignment-对象"><a href="#6-1-2-从比对好的序列创建-Alignment-对象" class="headerlink" title="6.1.2 从比对好的序列创建 Alignment 对象"></a>6.1.2 从比对好的序列创建 Alignment 对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio.Align <span class="keyword">import</span> Alignment</span><br><span class="line"><span class="comment"># 比对后的序列</span></span><br><span class="line">aligned_sequences = [<span class="string">&quot;CGGTTTTT&quot;</span>, <span class="string">&quot;AG-TTT--&quot;</span>, <span class="string">&quot;AGGTTT--&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(aligned_sequences)</span><br><span class="line"><span class="comment"># 不含 gap 的序列</span></span><br><span class="line">sequences = [aligned_sequence.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">             <span class="keyword">for</span> aligned_sequence <span class="keyword">in</span> aligned_sequences]</span><br><span class="line"><span class="built_in">print</span>(sequences)</span><br><span class="line"><span class="comment"># 类方法获取比对序列的坐标</span></span><br><span class="line">coordinates = Alignment.infer_coordinates(aligned_sequences)</span><br><span class="line"><span class="built_in">print</span>(coordinates)</span><br><span class="line"><span class="comment"># 补充不在比对结果中的碱基，打印原始序列</span></span><br><span class="line">sequences[<span class="number">0</span>] = <span class="string">&quot;C&quot;</span> + sequences[<span class="number">0</span>]</span><br><span class="line">sequences[<span class="number">1</span>] = sequences[<span class="number">1</span>] + <span class="string">&quot;AA&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sequences)</span><br><span class="line"><span class="comment"># 更新坐标</span></span><br><span class="line">coordinates[<span class="number">0</span>,:] +=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(coordinates)</span><br><span class="line"><span class="comment"># 创建 Alignment 对象</span></span><br><span class="line">aligment = Alignment(sequences,coordinates)</span><br><span class="line"><span class="built_in">print</span>(aligment)</span><br><span class="line"><span class="comment"># 可以不给 Alignment 类赋予 coordinates 参数，代表使用默认值 None，即无 gap，序列长度相同</span></span><br><span class="line">ungapped_alignment = Alignment([<span class="string">&quot;ACGTACGT&quot;</span>, <span class="string">&quot;AAGTACGT&quot;</span>, <span class="string">&quot;ACGTACCT&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(ungapped_alignment.coordinates)</span><br><span class="line"><span class="built_in">print</span>(ungapped_alignment)</span><br></pre></td></tr></table></figure>

<h4 id="6-1-3-常见-alignment-属性"><a href="#6-1-3-常见-alignment-属性" class="headerlink" title="6.1.3 常见 alignment 属性"></a>6.1.3 常见 alignment 属性</h4><p>Alignment 类的属性：</p>
<ul>
<li><p>sequences：互相比对的序列组成的<strong>列表</strong>。根据比对方式的不同，有以下几种类型：</p>
<ul>
<li>纯文本 python 字符串</li>
<li>Seq</li>
<li>MutableSeq</li>
<li>SeqRecord</li>
<li>bytes</li>
<li>bytearray</li>
<li>NumPy 数组（numpy.int32 数据类型）</li>
<li>any other object with a contiguous buffer of format “c”, “B”, “i”, or “I”;</li>
<li>由对象组成的列表或者元组，这些对象由 PairwiseAligner 对象创建的比对中的 alphabet 属性所定义。</li>
</ul>
<p>对于配对比对(pairwise alignment，即两条序列)来说，属性 target 和 query 分别是 sequences[0] 和 sequences[1] 的别名</p>
</li>
<li><p>coordinates：整数<strong>数组</strong>，存储了序列索引，以定义序列之间的对齐方式</p>
</li>
<li><p>score：比对分数，通过解析器在比对文件中找到，或者通过 PairwiseAligner 计算得到。</p>
</li>
<li><p>annotations：<strong>字典</strong>，储存比对相关注释信息</p>
</li>
<li><p>column_annotations：<strong>字典</strong>，与 alignment 长度相同，用以拓展 alignment，如 consensus 序列</p>
</li>
</ul>
<h3 id="6-2-对-alignment-进行切片与索引"><a href="#6-2-对-alignment-进行切片与索引" class="headerlink" title="6.2 对 alignment 进行切片与索引"></a>6.2 对 alignment 进行切片与索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Alignment 对象</span></span><br><span class="line">seqA = <span class="string">&#x27;CCGGTTTTT&#x27;</span></span><br><span class="line">seqB = <span class="string">&#x27;AGTTTAA&#x27;</span></span><br><span class="line">seqC = <span class="string">&#x27;AGGTTT&#x27;</span></span><br><span class="line">sequences = [seqA,seqB,seqC]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">coordinates = np.array([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Bio.Align <span class="keyword">import</span> Alignment</span><br><span class="line">alignment = Alignment(sequences,coordinates)</span><br><span class="line"><span class="built_in">print</span>(alignment)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 aligment 看成矩阵</span></span><br><span class="line"><span class="built_in">print</span>(alignment.length) <span class="comment">#列数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(alignment)) <span class="comment">#行数</span></span><br><span class="line"><span class="built_in">print</span>(alignment[<span class="number">0</span>]) <span class="comment">#第一行</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,<span class="number">0</span>]) <span class="comment">#第一列</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,:-<span class="number">1</span>]) <span class="comment">#所有行，不要最后一列</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,(<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>)]) <span class="comment">#取特定列</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>)]) <span class="comment">#取特定列</span></span><br><span class="line"><span class="built_in">print</span>(alignment[<span class="number">1</span>::<span class="number">1</span>]) <span class="comment">#取出子比对，即 sequences[1::1] 对应的那几行</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,-<span class="number">6</span>:]) <span class="comment">#取出最后6列</span></span><br><span class="line"><span class="built_in">print</span>(alignment[:,:]) <span class="comment">#拷贝该比对</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-获取-alignment-的信息"><a href="#6-3-获取-alignment-的信息" class="headerlink" title="6.3 获取 alignment 的信息"></a>6.3 获取 alignment 的信息</h3><h4 id="6-3-1-alignment-shape"><a href="#6-3-1-alignment-shape" class="headerlink" title="6.3.1 alignment shape"></a>6.3.1 alignment shape</h4><p>&#x3D;&#x3D;shape&#x3D;&#x3D; 属性获取行数与列数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(alignment.shape)</span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-比较-alignments"><a href="#6-3-2-比较-alignments" class="headerlink" title="6.3.2 比较 alignments"></a>6.3.2 比较 alignments</h4><p>只有两个 aligment.sequeces、alignment.coordinates 完全相等两个比对才相等，如果比对不相等（如 alignment &lt; alignment1）,则会先比较 aligment.sequeces，再比较 alignment.coordinates</p>
<h4 id="6-3-3-找出比对序列的索引"><a href="#6-3-3-找出比对序列的索引" class="headerlink" title="6.3.3 找出比对序列的索引"></a>6.3.3 找出比对序列的索引</h4><ul>
<li><p>对于配对比对，&#x3D;&#x3D;aligned&#x3D;&#x3D; 属性返回子序列的索引（仅 target 和 query 序列能比对上的索引，即没有引入 gap），如果这个比对（target 比 query）包含 N 个 chunk，则返回两个元组组成的数组，每个元组的长度为 N，每个元组中包含了 N 个 chunk 的起始位置组成的索引：</p>
<p>(((t_start1, t_end1), (t_start2, t_end2), …, (t_startN, t_endN)),((q_start1, q_end1), (q_start2, q_end2), …, (q_startN, q_endN)))</p>
<blockquote>
<p>  aligned 属性目前仅用于配对比对</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;indices&#x3D;&#x3D; 属性返回 1个 2D Numpy 数组，显示了alignment中每个字符的下标，gap标为 -1（数组中索引数量即 alignment 每一行包含 gap 的长度）</p>
</li>
<li><p>&#x3D;&#x3D;inverse_indices&#x3D;&#x3D; 属性返回 1 个含有 1D Numpy数组的列表，每个数组代表 alignment 每一行序列，数组中的数字即 alignment.sequences 序列每个碱基在 alignment 上的索引，不包含在 alignment 中的字符标记为 -1。（数组中索引数量与 sequences 碱基数相同）</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 Alignment 对象</span></span><br><span class="line">seqA = <span class="string">&#x27;CCGGTTTTT&#x27;</span></span><br><span class="line">seqB = <span class="string">&#x27;AGTTTAA&#x27;</span></span><br><span class="line">seqC = <span class="string">&#x27;AGGTTT&#x27;</span></span><br><span class="line">sequences = [seqA,seqB,seqC]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">coordinates = np.array([[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Bio.Align <span class="keyword">import</span> Alignment</span><br><span class="line">alignment = Alignment(sequences,coordinates)</span><br><span class="line"><span class="built_in">print</span>(alignment)</span><br><span class="line"></span><br><span class="line">pairwise_alignment = alignment[:<span class="number">2</span>,:]</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment)</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment.aligned)</span><br><span class="line"></span><br><span class="line"><span class="comment">#不同的 alignment 可能会有相同子序列（例如仅有gap不同）</span></span><br><span class="line">pairwise_alignment1 = Alignment([<span class="string">&quot;AAACAAA&quot;</span>,<span class="string">&quot;AAAGAAA&quot;</span>],</span><br><span class="line">                                np.array([[<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>]]))</span><br><span class="line">pairwise_alignment2 = Alignment([<span class="string">&quot;AAACAAA&quot;</span>,<span class="string">&quot;AAAGAAA&quot;</span>],</span><br><span class="line">                                np.array([[<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>]]))</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment1)</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment2)</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment1.aligned)</span><br><span class="line"><span class="built_in">print</span>(pairwise_alignment2.aligned)</span><br><span class="line"></span><br><span class="line"><span class="comment"># indices 属性返回1个 2D Numpy 数组，显示了alignment中每个字符的下标，gap标为 -1</span></span><br><span class="line"><span class="built_in">print</span>(alignment)</span><br><span class="line"><span class="built_in">print</span>(alignment.indices)</span><br><span class="line"><span class="built_in">print</span>(alignment.sequences)</span><br><span class="line"><span class="built_in">print</span>(alignment.inverse_indices)</span><br></pre></td></tr></table></figure>

<h4 id="6-3-4-计算-identities、mismatches、gaps"><a href="#6-3-4-计算-identities、mismatches、gaps" class="headerlink" title="6.3.4 计算 identities、mismatches、gaps"></a>6.3.4 计算 identities、mismatches、gaps</h4><p>&#x3D;&#x3D;counts&#x3D;&#x3D;方法计算配对比对的 identities、mismatches、gaps。如果是多序列比对，计算其中所有配对比对的identities、mismatches、gaps之和。</p>
<p>counts 方法返回 1 个 AlignmentCounts 对象，它是 1 个 namedtuple。该方法目前没有参数，未来可能会增加参数以允许用户自定义。</p>
<h2 id="3-biopython-常用模块"><a href="#3-biopython-常用模块" class="headerlink" title="3. biopython 常用模块"></a>3. biopython 常用模块</h2><h3 id="3-1-Alphabet（字母表）"><a href="#3-1-Alphabet（字母表）" class="headerlink" title="3.1 Alphabet（字母表）"></a>3.1 Alphabet（字母表）</h3><ol>
<li><p>DNA字母表</p>
<ul>
<li><p>DNA有一个4个字母的字母表（A、C、T、G）。</p>
</li>
<li><p>还有一些字母代表简并碱基，比如字母 S 可以代表碱基 C 或 G，字母 H 可以代表碱基 A、C 或 T，在 biopython 中这个字母表被称为模糊DNA (ambiguous_dna)。</p>
</li>
<li><p>DNA拥有一个字母表允许碱基修饰（ExtendedIUPACDNA）。</p>
</li>
</ul>
</li>
<li><p>蛋白质字母表</p>
<ul>
<li><p>蛋白质有20个氨基酸，每个氨基酸由字母表中的一个字母表示。</p>
</li>
<li><p>对于蛋白质来说也有一些字母可以代表非常见氨基酸（ExtendedIUPACProtein）。</p>
</li>
<li><p>还有一个简化的字母表，考虑到不同氨基酸共同的物理化学性质，可以将几种氨基酸混合成一个字母。</p>
</li>
</ul>
</li>
<li><p>二级结构字母表</p>
<ul>
<li>biopython 中还有1个字母表不是基于DNA或氨基酸的，而是基于二级结构。如螺旋、转角、链和卷曲等(<strong>H</strong>elix, <strong>T</strong>urn, <strong>S</strong>trand, <strong>C</strong>oil)。</li>
</ul>
</li>
</ol>
<p>由 IUPAC(国际纯粹与应用化学联合会) 定义的字母表作为 IUPAC 模块的类储存在 Biopython 中。父模块(Bio.Alphabet) 还包括更多类属性。以下是一些字母表属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bio.Alphabet 目前已被移除</span></span><br><span class="line"><span class="keyword">import</span> Bio.Alphabet</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Seq"><a href="#3-2-Seq" class="headerlink" title="3.2 Seq"></a>3.2 Seq</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>未完待续…</p>
<p>参考文献</p>
<ol>
<li>书籍《PYTHON FOR BIOINFORMATICS SECON - SEBASTIAN BASSI》</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/01/biopython/" data-id="clrp1s2na000070b9h5as8dmb" data-title="biopython中文说明书（翻译自2023年英文说明书）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/biopython/" rel="tag">biopython</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/01/22/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/">生物信息</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/biopython/" rel="tag">biopython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" rel="tag">基因组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%97%85%E6%AF%92/" rel="tag">病毒</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/biopython/" style="font-size: 20px;">biopython</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" style="font-size: 10px;">基因组</a> <a href="/tags/%E7%97%85%E6%AF%92/" style="font-size: 10px;">病毒</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/01/22/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2024/01/01/biopython/">biopython中文说明书（翻译自2023年英文说明书）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>